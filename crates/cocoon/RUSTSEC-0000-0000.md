```toml
[advisory]
id = "RUSTSEC-0000-0000"
package = "cocoon"
date = "2023-10-15"
url = "https://github.com/fadeevab/cocoon/issues/22"
categories = ["crypto-failure"]
cvss = "CVSS:3.1/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:N/RC:C"
keywords = ["nonce", "stream-cipher"]

[affected]
functions = {"cocoon::Cocoon::encrypt" = ["<= 0.3.3"], "cocoon::Cocoon::dump" = ["<= 0.3.3"], "cocoon::Cocoon::wrap" = ["<= 0.3.3"], "cocoon::MiniCocoon::encrypt" = ["<= 0.3.3"], "cocoon::MiniCocoon::dump" = ["<= 0.3.3"], "cocoon::MiniCocoon::wrap" = ["<= 0.3.3"]}

[versions]
patched = [">= 0.4.0"]
```

# Sequential calls of `encrypt`, `wrap`, and `dump` produce the same ciphertext

**Problem**: Trying to create a new encrypted message with the same cocoon object generates the same ciphertext.

Cocoon API was intended to be a one-shot: create cocoon, encrypt, release.
Nonetheless, it was implicit, and it was found that the API could be used
in a stream-cipher way: create cocoon, encrypt many times with
expectation of producing a new cipher text per every call.

**Cause**: `StdRng` produces the same nonce because `StdRng::clone` resets its state.

**Measure**: Make encryption API mutable (`encrypt`, `wrap`, and `dump`).

**Workaround**: Creating a new cocoon object with a new seed per each encryption.

## Example

```rust
let cocoon = MiniCocoon::from_password(b"password", &[1; 32]);

let mut data = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&mut data)?;

let mut data = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&mut data)?;
```

## Workaround

Creating a new cocoon object with a new seed per each `encrypt`/`wrap`/`dump` call.

```rust
let cocoon = MiniCocoon::from_password(b"password", &[1; 32]);
let mut data = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&mut data)?;

let cocoon = MiniCocoon::from_password(b"password", &[2; 32]);
let mut data = "my secret data".to_owned().into_bytes();
let _ = cocoon.encrypt(&mut data)?;
```
